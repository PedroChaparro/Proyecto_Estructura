<!DOCTYPE html>
<html>
<head>

    <meta charset="UTF-8">

    <style>
        #contenido-inferior{
            margin: auto;
            margin-top: -30px;
            width: 960px;
            height: 1740px;
            background-color: white;
        }
        #contenido-superior{
            margin: auto;
            margin-top: -60px;
            width: 960px;
            height: 60px;
            background-color: white;
        }
        #contenido-inferior-Pila{
            margin: auto;
            margin-top: 0px;
            width: 960px;
            height: 6330px;
            background-color: white;
        }

        #codigo{

            background-color: white;

        }

        h1{

            font-family: Arial, Helvetica, sans-serif;

        }

    </style>
    
    <link rel="stylesheet" href="./css/styles.css ", type="text/css">

    <link rel="stylesheet" href="highlight/styles/gml.css">
    <script src="highlight/highlight.pack.js"></script>
    <script>hljs.highlightAll();</script>
    
    <title>
        LISTA DOBLE C++
    </title>
</head>
    
<body>
    <div id="particles-js"></div>
    
    <div id="codigo">

        <br>
        <h1>NODO DE LA LISTA DOBLEMENTE ENLAZADA:</h1>

        <pre>

            <code>

    # include <iostream>
    #include <string>
    
    
    using namespace std ; 
    
    //--------------------listNode----------------------//
    
    class listNode{
    
        private: 
            //Atributos de la clase
            int object; 
            listNode* next; 		//Puntero al nodo siguiente
            listNode* previous; 	//Puntero al nodo anterior
    
        public: 
            //Constructores de la clase
            listNode(); 
            listNode(int objeto); 
            listNode(int objeto, listNode* siguiente, listNode* previous); 
            
            //Métodos de la clase
            
            //Método para asignar un nodo siguiente
            void enlazarSiguiente(listNode* siguiente){
                
                next = siguiente; 
                
            }; 
            
            //Método para asignar un nodo anterior
            void enlazarAnterior(listNode* anterior){
                
                previous = anterior; 
                
            }; 
            
            //Método para asignar un objeto al nodo
            
            void setObject(int objeto){
                
                object = objeto; 
                
            }; 
            
            //Método para obtener la dirección del nodo siguiente
            listNode* getNextTo(){
                
                return next; 
                
            }; 
            
            //Método para obtener la dirección del nodo anterior
            listNode* getPreviousTo(){
                
                return previous; 
                
            }; 
            
            //Método par obtener el objeto guardado por un nodo
            int getObject(){
                
                return object; 
                
            }; 
            
            //Método para saber si un nodo almacena un objeto dado 
            bool isEquals(int objeto){
                
                if(object == objeto){
                    
                    //Si el objeto almacenado por el nodo es igual al objeto pasado al método se retorna True
                    //El retorno será 1
                    return true; 
                    
                }else{
                    
                    //Si son diferentes, se retorna False
                    //El retorno será 0
                    return false; 
                    
                }
                
                
            }
            
            //Método para imprimir la información de todos los nodos existentes (cabeza -> cola)
            
            void toString(){
            
                cout << "ListNode: \n";
                cout << "OBJETO ALMACENADO: ";
                cout << object; 
                cout << "\n"; 
                cout << "\nSIGUIENTE NODO --> \n\n";
                
                if(getNextTo() != 0 ){
                    
                    //Si el siguiente nodo existe
                    getNextTo() -> toString(); 
                    
                }else{
                    
                    cout << "NULL\n\n"; 
                    
                }
                
            }
            
            //Método para imprimir la información de todos los nodos existentes en dirección contradia (cola -> cabeza) 
            void toStringINV(){
                
                cout << "ListNode: \n";
                cout << "OBJETO ALMACENADO: ";
                cout << object; 
                cout << "\n"; 
                cout << "\ANTERIOR NODO --> \n\n";
                
                if(getPreviousTo() != 0){
                        
                    getPreviousTo() -> toStringINV(); 
                    
                }else{
                    
                    cout << "NULL\n\n"; 
                    
                }
                
            }
            
            
    };

    //Implementación de la clase listNode

    //Constructor de un nodo vacío
    listNode::listNode(){
        
        object = 0; 	//Valor por defecto del objeto almacenado en el nodo
        next = 0; 		//0 es un puntero NULL
        
    }

    //Constructor de un nodo pasando el objeto a almacenar
    listNode::listNode(int objeto){
        
        object = objeto; 	//Valor por defecto del objeto almacenado en el nodo
        next = 0; 			//0 es un puntero NULL
        
    }


    //Constructor de un nodo completo, paasando el objeto y los punteros al anterios y siguiente
    listNode::listNode(int objeto, listNode* siguiente, listNode* anterior){
        
        object = objeto; 
        next = siguiente; 
        previous = anterior; 
        
    }

            </code>

        </pre>

        <h1>CÓDIGO DE LA LISTA DOBLEMENTE ENLAZADA</h1>
        <br>

        <pre>

            <code>

    //--------------------list----------------------//

    class DoubleLinkedList{
                    
        private: 
            //Atrubutos de la clase
            int size; 
            listNode* head; 	//Referencia a un nodo que será la cabeza
            listNode* tail; 	//Referencia a un nodo que será la cola
        
        public: 
        
            //Constructor de la lista vacía
            List(){
                
                head = NULL; 
                tail = NULL; 
                size = 0; 
                
            }; 
            
            //Métodos de la clase
            
            //Método para saber si la lista está vacía
            bool isEmpty(){
                
                if(head == 0){
                    
                    //Si la cabeza es nula, se retorna true
                    return true; 
                    
                }else{
                    
                    return false; 
                    
                }
                
            }
            
            //Método para imprimir la lista
            
            void listToString(){
                
                //Se llama al método del nodo para imprimir en dirección derecha
                head -> toString(); 
                
            }
            
            //Método para imprimir la lista en el sentido contrario
            void listToStringINV(){
                
                //Se llama al método del nodo para imprimir en dirección izquierda
                tail -> toStringINV(); 
                
            }
            
            //Método para obtener la cabeza
            listNode* getHeadNode(){
                
                return head; 
                
            }
            
            //Método para obtener la cola
            listNode* getTailNode(){
                
                return tail; 
                
            }
            
            //Mëtodo para insertar un objeto por la cola
            void insertTail(int objeto){
                
                if(isEmpty() == true){
                    
                    //Si la lista está vacía, la cabeza y la cola serán el nuevo nodo
                    head = new listNode(objeto); 
                    tail = head; 
                    size++; 
                    
                }else{
                    
                    //Si la lista no está vacía 
                    
                    //Se crea el nuevo nodo 
                    listNode* temp = new listNode(objeto); 
                    
                    temp -> enlazarAnterior(tail); 	//El nodo anterior al nuevo nodo será la anterior cola
                    tail -> enlazarSiguiente(temp);	//La anterior cola se enlaza al nuevo nodo
                    tail = tail -> getNextTo();  	//La nueva cola será el nodo siguiente a la anterior cola
                    size++; 
                    
                }
                
            }
            
            //Método para añadir un elemento a la lista
            void add(int objeto){
                
                //Se llama el método insertTail
                insertTail(objeto); 
                
            }
            
            //Método par obtener el tamaño de la lista
            int getSize(){
                
                return size; 
                
            }
            
            //Método para anular la lista
            void clear(){
                
                head = NULL; 
                tail = NULL; 
                size = 0; 
                
            }
            
            //Método para remover un objeto de la lista
            void remove(int objeto){
                
                listNode* current; 
                listNode* before; 
                
                current = head; 
                before = NULL; 
                
                bool finded = false; 
                
                //Se busca el nodo y el anterior
                while((current != NULL) && !finded){
                    
                    //Se verifica si ya se encontró el objeto
                    finded = (current -> getObject() == objeto); 
                    
                    //Si no se ha encontrado, se sigue iterando entre los nodos
                    if(!finded){
                        
                        before = current; 
                        current = current -> getNextTo(); 
                        
                    }
                    
                }
                
                if(current != NULL){
                    
                    //Si se encontró el nodo que contiene el objeto
                    
                    if(current == head){
                        
                        //Si el nodo que lo contiene es la cabeza, la nueva cabeza será el segundo nodo
                        head = current -> getNextTo(); 
                        
                    }else{
                        
                        before -> enlazarSiguiente(current -> getNextTo()); 	//El anterior nodo se enlaza al siguiente nodo
                        (current -> getNextTo()) -> enlazarAnterior(before); 	//El siguiente nodo se enlaza an anterior del nodo encontrado
                        
                    }
                    
                    delete current; 	//Se elimina el nodo encontrado 
                    
                }
                
                
            }
            
            //Método para buscar un objeto dentro de la lista
            bool search(int object){
                
                //Nodo para recorrer la lista
                listNode* temp; 
                
                //Se recorre la lista
                for(temp = head; temp != NULL; temp = temp -> getNextTo()){
                    
                    if(temp -> getObject() == object){
                        
                        return true; 	//Si se encuentra el objeto se retorna true
                        break; 			//Se rompe el for para dejar de buscar
                        
                    }
                    
                }
                
            }
            
        
    }; 


            </code>

        </pre>

    </div>

    <script src="js/particles.min.js"></script>
    <script src="js/app.js"></script>

</body>
</html>