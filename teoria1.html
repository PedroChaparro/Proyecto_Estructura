<!DOCTYPE html>
<html>
    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title> :: TEORÍA :: </title>
        <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    
        <style>
            #letrascajas{
                color: rgb(255, 255, 255);
                text-shadow: 0 0 20px rgb(255, 255, 255);
            }
    
            #subtituloCaja{
    
                color: rgb(255, 255, 255);
                text-shadow: 0 0 20px rgb(255, 255, 255);
                margin-left: 20px;
    
            }
    
            #textP{
    
                margin-left: 20px;
                margin-right: 20px;
    
            }

            body{

                overflow-x: hidden;

            }
    
        </style>
    
        <!-- ESTILOS CSS -->
        <link rel="stylesheet" href="./css/styles.css ", type="text/css">
    </head>
    
    <body>
    
        <!-- DIV PARTÍCULAS -->
        <div id="particles-js"></div>

    |<!-- MENÚ DE NAVEGACIÓN -->
    <div class="container" id="contenido-superior">

        <table id="img_table" align="center"> 
        <tr>
            <td>
                <a id="a2" href="prueba.html" target="_blank">
                    <h2 class="container" id ="letras" style="margin-left: 40px;"><a href="prueba.html" id="a2"><span>INICIO</span></a></h2>
                </a>
            </td>
            <td>
                <a id="a3" href="teoria.html" target="_blank">
                    <h2 class="container" id ="letras" style="margin-left: 40px;"><a href="implementaciones.html" id="a3"><span>IMPLEMENTACIONES</span></a></h2>
                </a>
            </td>
            <td>
                <a id="a4" href="transformaciones.html">
                    <h2 class="container" id ="letras" style="margin-left: 40px;"><a href="transformaciones.html" id="a4"><span>TRANSFORMACIONES D/C </span></a></h2> 
                </a>
            </td>
            <td>
              <a id="a4" href="transformaciones_2.html">
                  <h2 class="container" id ="letras" style="margin-left: 40px;"><a href="transformaciones_2.html" id="a4"><span>TRANSFORMACIONES C/D </span></a></h2> 
              </a>
          </td>
            
        </tr>
    </table>
  
    </div>
    
    <center>
        <div id="boton2">
            <center>
                <font color="#fff"><h2 id="letrascajas">LISTA SIMPLEMENTE ENLAZADA</h2></font>
                <font color="#fff"><p align="justify" id="textP">Una lista simplemente enlazada es una de las estructuras de datos más básicas, 
                consiste en una secuencia de nodos que están conectados mediante punteros al siguiente nodo, como se puede ver en la siguiente imágen:  </p></font>
                <img src="img\listaSimpleEnlazada.jpg" alt="EJEMPLO DE LISTA SIMPLE" width="600" height="200">
                <font color="#fff"><p align="justify" id="textP">Como se puede observar también en la anterior imagen, el nodo final (al cual llamamos cola), no tiene un 
                nodo siguiente (su puntero a punta a Nulo), lo cual indica que al momento de hacer un recorrido a través de todos los nodos, este terminará al llegar a la cola.
                </p></font>
                <font color="#fff"><h3 id="subtituloCaja" align="left">OPERACIONES BÁSICAS:</h2></font>
                    <font color="#fff"><p align="justify" id="textP">Una lista simplemente enlazada debe tener como mínimo, la capacidad de: <br><br>
                    - Saber si está vacía (Método IsEmpty() ) <br>
                    - Obtener el tamaño o la cantidad de nodos (Método GetSize() ) <br>
                    - Anular la lista (Método Clear() ) <br>
                    - Obtener el primer nodo ( Método getHead() ) <br>
                    - Obtener el último nodo ( Método getTail() ) <br>
                    - Buscar un objeto dentro de la lista ( Método search() ) <br>
                    - Añadir un objeto a la lista ( método add() ) <br>
                    - Remover un objeto de la lista ( método remove() )</p></font>   
    
            </center>
        </div>
    </center>
    
    <center>
        <div id="boton3">
            <center>
                <font color="#fff"><h2 id="letrascajas">LISTA DOBLEMENTE ENLAZADA</h2></font>
                <font color="#fff"><p align="justify" id="textP"> El funcionamiento de esta estructura está basado en la lista simplemente enlazada. Esta lista también
                consiste en una secuencia de nodos que se conectan entre sí mediante punteros, pero la lista doble tiene una gran diferencia, y es que no existe un solo puntero,
                ahora tenemos un segundo puntero que enlaza cada nodo a su anterior, como se aprecia en la siguiente imágen:  </p></font>
                <img src="img\listaDobleEnlazada.jpg" alt="EJEMPLO DE LISTA SIMPLE" width="600" height="200">
                <br>
                <font color="#fff"><p align="justify" id="textP"> Lo anterior nos permite comenzar a recorrer la lista desde la cola. Es importante tener en cuenta que 
                si comenzamos el recorrido por la cabeza, este se acabará al llegar a la cola, ya que el siguiente nodo luego de la cola sigue siendo nulo. </p></font>
                <font color="#fff"><h3 id="subtituloCaja" align="left">OPERACIONES BÁSICAS:</h2></font>
                    <font color="#fff"><p align="justify" id="textP"> Las operaciones básicas de esta estructura son las mismas que la lista simplemente enlazada, a diferencia de que 
                    ahora podríamos agregar un método que permita realizar el recorrido comenzando por la cola, para hacer búsquedas más eficientes. </p></font>
            </center>
        </div>
    </center>
    
    <center>
        <div id="boton2" style="margin-top: 100px;">
            <center>
                <font color="#fff"><h2 id="letrascajas">LISTA CIRCULAR SIMPLE</h2></font>
                <font color="#fff"><p align="justify" id="textP"> Una lista circular simple es una lista simplemente enlazada sin fin, se dice que no tiene fin porque al momento de hacer el recorrido
                luego de la cola, se pasa nuevamente a la cabeza. Lo anterior ocurre porque a diferencia de una lista simplemente enlazada normal, ahora la cola no apunta a Nulo, sino que apunta a la cabeza de la lista, 
                lo cual se puede entender con mayor facilidad viendo la siguiente imágen:  </p></font>
                <img src="img\listaSimpleCircular.jpg" alt="EJEMPLO DE LISTA SIMPLE" width="600" height="200"><br>
                <font color="#fff"><h3 id="subtituloCaja" align="left">OPERACIONES BÁSICAS:</h2></font>
                <font color="#fff"><p align="justify" id="textP"> Al tratarse de una lista, sus operaciones básicas son las mismas de la lista simple y doblemente enlazada, lo único a resaltar es que 
                al momento de recorrer la lista, es necesario contar con una condición de parada, de lo contrario, se seguirá recorriendo la lista como si se tratara de un bucle. </p></font>
    
        </div>
    </center>
    
    <center>
        <div id="boton3" style="margin-top: 100px;">
            <center>
                <font color="#fff"><h2 id="letrascajas">LISTA CIRCULAR DOBLE</h2></font>
                <font color="#fff"><p align="justify" id="textP"> En esta estructura, cada nodo tiene dos punteros, y cada nodo, siempre y cuando exista más de un objeto almacenado apunta a dos nodos, 
                incluyendo la cabeza y la cola de la lista. Recordando la lista doblemente enlazada, el nodo anterior a la cabeza era nulo, y el nodo siguiente a la cola, era nulo, pero ahora, decimos
                que el nodo anterior a la cabeza es la cola, y el nodo siguiente a la cola es la cabeza. <br><br>
                Para un mejor entendimiento, veamos la siguiente imágen:  </p></font>
                <img src="img\listaDobleCircular.jpg" alt="EJEMPLO DE LISTA SIMPLE" width="600" height="200"><br>
                <font color="#fff"><h3 id="subtituloCaja" align="left">OPERACIONES BÁSICAS:</h2></font>
                <font color="#fff"><p align="justify" id="textP"> Sigue conservando como mínimo las operaciones de las demás listas, pero hay dos consideraciones: <br><br>
                1- Al igual que la lista circular simplemente enlazada es necesario tener una condición de parada, para evitar recorrer la lista en un bucle. <br> <br>
                2- La lista puede estar en la capacidad de comenzar su recorrido hacia cualquier dirección en cualquier nodo, ya que todos están conectados entre sí. </p></font>
            </center>
        </div>
    </center>
    
    <center>
        <div id="boton2" style="margin-top: 100px;">
            <center>
                <font color="#fff"><h2 id="letrascajas">PILA (STACK)</h2></font>
                <font color="#fff"><p align="justify" id="textP"> Las pilas vienen a ser una colección ordenada de elementos 
                    a los que solo podemos acceder desde un único lugar, el cual sería uno de sus extremos.
                    Los elementos de esta que querramos añadir o eliminar solo se podrán contactar por la parte superior
                    de la pila, a la cual llamamos cabeza. <br><br>
                    Podremos entender más fácilmente cómo se representa en la siguiente imágen:  </p></font>
                    <img src="img\pilaStack.jpg" alt="EJEMPLO DE PILA" width="432" height="216"><br>
                    <font color="#fff"><h3 id="subtituloCaja" align="left">OPERACIONES BÁSICAS:</h2></font>
                    <font color="#fff"><p align="justify" id="textP"> Una pila debe tener como mínimo, la capacidad de: <br><br>
                        - Saber si está vacía (Método IsEmpty() ) <br>
                        - Anular la pila (Método Clear() ) <br>
                        - Obtener el tamaño de la pila ( Método size() ) <br>
                        - Lee el último elemento de la pila ( Método peek() ) <br>
                        - Extraer el último elemento de la pila ( Método pop() ) <br>
                        - Añadir un elemento ( Método push() ) <br>
                        - Buscar un objeto dentro de la pila ( Método search() ) <br>
                        - Añadir un objeto a la pila ( método insert() ) <br>
                        - Remover un objeto de la pila ( método remove() )</p></font>   
            </center>
        </div>
    </center>
    
    <center>
        <div id="boton3" style="margin-top: 100px;">
            <center>
                <font color="#fff"><h2 id="letrascajas">COLA</h2></font>
                <font color="#fff"><p align="justify" id="textP"> En las colas, todos sus elementos mantienen un orden 
                    específico, de tal manero de que solo se pueden añadir elementos por un extremo, osea el final de la cola,
                    y eliminar o extraelos por el otro extremo de la misma, el cual se llama frente.<br><br>
                    Para un mejor entendimiento, como se representa en la siguiente imágen:  </p></font>
                    <img src="img\cola.jpg" alt="EJEMPLO DE COLA" width="540" height="270"><br>
                    <font color="#fff"><h3 id="subtituloCaja" align="left">OPERACIONES BÁSICAS:</h2></font>
                    <font color="#fff"><p align="justify" id="textP"> Una cola debe tener como mínimo, la capacidad de: <br><br>
                        - Saber si está vacía (Método IsEmpty() ) <br>
                        - Anular la cola (Método Clear() ) <br>
                        - Obtener el tamaño de la cola ( Método size() ) <br>
                        - Buscar un objeto dentro de la cola ( Método search(Object object) ) <br>
                        - Extraer o eliminar el último elemento ( Método extract() ) <br>
                        - Añadir un objeto a la cola ( Método insert(Object object) ) <br>
                        - Remover un objeto de la cola ( Método remove() )</p></font>   
         </p></font>
            </center>
        </div>
    </center>
    <br>
    <br>
    <br>

    <center>
        <div id="boton2" style="margin-top: 100px;">
            <center>
                <font color="#fff"><h2 id="letrascajas">COLA CON PRIORIDAD</h2></font>
                <font color="#fff"><p align="justify" id="textP"> Una cola de prioridad, tiene, en el fondo, el mismo funcionamiento que una cola normal,
                    a diferencia de que ahora cada elemento tiene una prioridad asignada. <br><br>

                    En este tipo de cola, la lista de elementos con mayor prioridad serán extraídos o usados antes que los subsiguientes en orden de prioridad. 
                    En caso de que los elementos tengan la misma prioridad, estos serán extraídos siguiento el FIFO (Primero que entró, el el primero en salir). 
                </p></font><br>
                <img src="img\colaconPrioridad.png" alt="EJEMPLO DE COLA" width="540" height="270">
                <font color="#fff"><h3 id="subtituloCaja" align="left">OPERACIONES EXTRAS:</h2></font>
                <font color="#fff"><p align="justify" id="textP"> 

                    -Añadir elemento con prioridad: Se puede hacer mediante posiciones de arreglos, o mediante listas. <br>
                    <br>-Eliminar o sacar elementos de la cola respetando el orden de prioridad. 

                </p></font>   
                
            </center>
        </div>
    </center>
    
    <center>
        <div id="boton3" style="margin-top: 100px;">
            <center>
                <font color="#fff"><h2 id="letrascajas">ÁRBOL BINARIO</h2></font>
                <font color="#fff"><p align="justify" id="textP">
                    Un árbol es una estructura de datos en la que se hay un conjunto de uno o más nodos tales que hay un
                    nodo diseñado de manera especial llamado raíz, el cual es el principal ya que no tiene antecesores.
                    Los nodos que suceden a la raíz se dividen en conjuntos distintos, de manera que cada uno de estos
                    conjuntos en un árbol, los cuales se les denomina como subárboles de la raíz. <br><br>
                    En los árboles binarios, cada nodo puede tener 0, 1 o 2 hijos (subárboles). El nodo de la izquierda
                    se le conoce como hijo izquierdo y el nodo de la derecha como hijo derecho. <br><br>
                </p></font>
                <img src="img\arbol.jpg" alt="EJEMPLO DE ÁRBOL" width="450" height="240"><br><br>
                <font color="#fff"><h3 id="subtituloCaja" align="left">OPERACIONES BÁSICAS:</h2></font>
                    <font color="#fff"><p align="justify" id="textP">
                        - Recorrido in-orden <br>
                        - Recorrido pos-orden <br>
                        - Recorrido pre-orden <br>
                        - Insertar elemento. <br>
                        - Eliminar elemento.
                    </p></font>
            
            </center>
        </div>
    </center>
    <br>
    <br>
    <br>

    <center>
        <div id="boton2" style="margin-top: 100px;">
            <center>
                <font color="#fff"><h2 id="letrascajas">ÁRBOL BINARIO DE BÚSQUEDA</h2></font>
                <font color="#fff"><p align="justify" id="textP">
                    Un árbol binario de búsqueda es un árbol binario que se construye de un modo que le permite estar optimizado para
                    realizar búsquedas entre sus nodos. <br><br>
                    En este tipo de árbol binario, los nodos con un valor inferior al padre se organizan hacia la izquierda, caso contrario
                    de los nodos con un valor mayor al padre, los cuales se organizan a la derecha. <br><br>
                    Estos árboles soy muy eficientes, ya que permiten ahorrar parte de la recursividad al saber en qué lado está ubicado el nodo que 
                    buscamos. 
                </p></font><br>
                <img src="img\arbolBB.jpg" alt="EJEMPLO DE COLA" width="450" height="240"><br><br>
                <font color="#fff"><h3 id="subtituloCaja" align="left">OPERACIONES BÁSICAS:</h2></font>
                <font color="#fff"><p align="justify" id="textP">
                    - Recorrido in-orden <br>
                    - Recorrido pos-orden <br>
                    - Recorrido pre-orden <br>
                    - Insertar elemento teniendo en cuenta la optimización <br>
                    - Eliminar elemento.
                </p></font>
                
            </center>
        </div>
    </center>
    
    <center>
        <div id="boton3" style="margin-top: 100px;">
            <center>
                <font color="#fff"><h2 id="letrascajas">ÁRBOL AVL</h2></font>
                <font color="#fff"><p align="justify" id="textP">
                    Los árboles AVL son un tipo de árbol binario de búsqueda, donde cada nodo, al momenoto de ser insertado cumple la propiedad
                    de equilibrado AVL. <br><br>
                    La anterior propiedad nos dice que las alturas de los árboles (Izquierdo y derecho) no pueden tener una diferencia de más de 1. Para que
                    un árbol pueda ser considerado AVL, el factor de equilibrio de cada sub-arbol debe encontrarse en el rango [-1,1].
                </p></font><br>
                <img src="img\treeAVL.jpg" alt="EJEMPLO DE COLA" width="470" height="276"><br><br>
                <font color="#fff"><h3 id="subtituloCaja" align="left">OPERACIONES BÁSICAS:</h2></font>
                    <font color="#fff"><p align="justify" id="textP">
                        - Inserción AVL. <br>
                        - Elminación de árbol binario de búsqueda. <br>
                        - Re-equilibrado. <br>
                        - Calculo de factor de equilibrio. 
                    </p></font>
                
         </p></font>
            </center>
        </div>
    </center>
    <br>
    <br>
    <br>
    
    
        <!-- JS PARTÍCULAS -->
        <script src="js/particles.min.js"></script>
        <script src="js/app.js"></script>
    
    </body>
    </html>